package com.capgemini.java;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

public class Hand implements Comparable<Hand> {
	private boolean isColor;
	private int setupValue = 0;
	private List<Map.Entry<Integer, Integer>> sortedCards;
	private Map<Integer, Integer> hand = new TreeMap<>(Collections.reverseOrder());

	public void addCardsToHand(List<Card> cardList) {
		checkCardsColor(cardList);
		for (Card card : cardList) {
			int cardValueCounter = 0;
			if (hand.get(card.getCardValue().getValue()) != null) {
				cardValueCounter = hand.get(card.getCardValue().getValue());
			}
			hand.put(card.getCardValue().getValue(), 1 + cardValueCounter);
		}
		sortCards();
		calculateSetupValue();
	}

	private void checkCardsColor(List<Card> cardList) {
		boolean allCardsOneColor = true;
		String firstCardColor = "";
		for (Card card : cardList) {
			if (firstCardColor.isEmpty()) {
				firstCardColor = card.getCardColor();
			}
			if (card.getCardColor() != firstCardColor) {
				allCardsOneColor = false;
			}
		}
		this.isColor = allCardsOneColor;
	}

	private void calculateSetupValue() {
		boolean idCardCounterEqualFive = (sortedCards.size() == 5);
		boolean isValueDiffFirstAndLastCardEqualFour = ((sortedCards.get(0).getKey()
				- sortedCards.get(sortedCards.size() - 1).getKey()) == 4);
		boolean isOneAfterTheOther = (idCardCounterEqualFive && isValueDiffFirstAndLastCardEqualFour);
		if (!idCardCounterEqualFive) {
			String cardQuantities = "";
			for (Map.Entry<Integer, Integer> card : sortedCards) {
				cardQuantities += card.getValue().toString();
			}
			this.setupValue = CardSetup.getEnum(cardQuantities).getSetupValue();
		}
		boolean isColorAndValueDifferenceFour = (isColor&&isValueDiffFirstAndLastCardEqualFour);
		if(isColorAndValueDifferenceFour&&sortedCards.get(0).getKey()==11){
			this.setupValue = 8;
		}
		if(isColorAndValueDifferenceFour&&sortedCards.get(0).getKey()==14){
			this.setupValue = 9;
		}
		if(isColorAndValueDifferenceFour){
			this.setupValue = 5;
		}
		if(isValueDiffFirstAndLastCardEqualFour){
			this.setupValue = 4;
		}
	}

	private void sortCards() {
		sortedCards = new ArrayList<Map.Entry<Integer, Integer>>(hand.entrySet());
		Collections.sort(sortedCards, new sortByCardQuantityThenByCardValue<Integer, Integer>());
	}

	@Override
	public int compareTo(Hand secondHand) {
		if (this.setupValue > secondHand.setupValue) {
			return 1;
		} else if (this.setupValue < secondHand.setupValue) {
			return -1;
		} else {
			for (int i = 0; i < this.sortedCards.size(); i++) {
				if (this.sortedCards.get(i).getKey() > secondHand.sortedCards.get(i).getKey()) {
					return 1;
				}
				if (this.sortedCards.get(i).getKey() < secondHand.sortedCards.get(i).getKey()) {
					return -1;
				}
			}
		}
		return 0;
	}

	// Comparator that sorts Map.Entry objects with Comparable keys and values
	// Source:
	// http://stackoverflow.com/questions/3074154/sorting-a-hashmap-based-on-value-then-key
	private class sortByCardQuantityThenByCardValue<K extends Comparable<? super K>, V extends Comparable<? super V>>
			implements Comparator<Map.Entry<K, V>> {

		public int compare(Map.Entry<K, V> firstCard, Map.Entry<K, V> secondCard) {
			int cardQuantity = secondCard.getValue().compareTo(firstCard.getValue());
			if (cardQuantity != 0) {
				return cardQuantity;
			} else {
				return secondCard.getKey().compareTo(firstCard.getKey());
			}
		}

	}

}
