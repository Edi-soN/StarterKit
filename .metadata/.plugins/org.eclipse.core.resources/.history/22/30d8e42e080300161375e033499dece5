package com.capgemini.java;

import java.awt.Point;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

public class Game {
	private Map<Point, Cell> cellMap = new HashMap<>();

	public Game(List<Cell> cellList) {
		for (Cell cell : cellList) {
			cellMap.put(cell.getCellPosition(), cell);
		}
		addNeighboursPositions();
	}

	public Game(int cellBoardWidth, int cellBoardHeight) {
		// TODO
	}

	private void addNeighboursPositions() {
		int[][] cellOffsets = new int[][] { { -1, -1 }, { -1, 0 }, { -1, 1 }, { 0, -1 }, { 0, 1 }, { 1, -1 }, { 1, 0 },
				{ 1, 1 } };
		for (Entry<Point, Cell> entry : cellMap.entrySet()) {
			for (int[] offset : cellOffsets) {
				int positionX = entry.getValue().getCellPosition().x + offset[0];
				int positionY = entry.getValue().getCellPosition().y + offset[1];
				Point point = new Point(positionX, positionY);
				if (cellMap.containsKey(point)) {
					entry.getValue().setNeighborsPositionsList(point);
				}
			}
		}
	}

	private void countAliveNeighbors() {
		for (Entry<Point, Cell> entry : cellMap.entrySet()) {
			int aliveNeighborsCounter = 0;
			for (Point point : entry.getValue().getNeighborsPositionsList()) {
				if (cellMap.get(point).getCellState() == CellState.ALIVE.getValue()) {
					entry.getValue().setNumberOfAliveNeighbors(++aliveNeighborsCounter);
				}
			}
		}
	}

	public void calculateNextGeneration() {
		countAliveNeighbors();
		
	}

}
